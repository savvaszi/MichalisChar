/**
 * WordPress REST API Client for Astro
 * 
 * Auto-generated by PhantomWP
 * API URL: https://miniondonuts.com/wp-json
 * 
 * Usage in Astro pages:
 * ---
 * import { getPosts, getPost } from '../lib/wordpress';
 * const posts = await getPosts();
 * ---
 */

const WP_API_URL = 'https://miniondonuts.com/wp-json';
const WP_REST_BASE = `${WP_API_URL}/wp/v2`;

// ============================================================================
// Types
// ============================================================================

export interface WPPost {
  id: number;
  date: string;
  date_gmt: string;
  slug: string;
  status: string;
  type: string;
  link: string;
  title: { rendered: string };
  content: { rendered: string; protected: boolean };
  excerpt: { rendered: string; protected: boolean };
  author: number;
  featured_media: number;
  comment_status: string;
  ping_status: string;
  sticky: boolean;
  template: string;
  format: string;
  categories: number[];
  tags: number[];
  _embedded?: {
    author?: WPUser[];
    'wp:featuredmedia'?: WPMedia[];
    'wp:term'?: Array<WPCategory[] | WPTag[]>;
  };
}

export interface WPPage {
  id: number;
  date: string;
  date_gmt: string;
  slug: string;
  status: string;
  type: string;
  link: string;
  title: { rendered: string };
  content: { rendered: string; protected: boolean };
  excerpt: { rendered: string; protected: boolean };
  author: number;
  featured_media: number;
  comment_status: string;
  ping_status: string;
  template: string;
  parent: number;
  menu_order: number;
  _embedded?: {
    author?: WPUser[];
    'wp:featuredmedia'?: WPMedia[];
  };
}

export interface WPMedia {
  id: number;
  date: string;
  slug: string;
  type: string;
  link: string;
  title: { rendered: string };
  author: number;
  caption: { rendered: string };
  alt_text: string;
  media_type: string;
  mime_type: string;
  source_url: string;
  media_details: {
    width: number;
    height: number;
    file: string;
    sizes: Record<string, {
      file: string;
      width: number;
      height: number;
      mime_type: string;
      source_url: string;
    }>;
  };
}

export interface WPCategory {
  id: number;
  count: number;
  description: string;
  link: string;
  name: string;
  slug: string;
  taxonomy: string;
  parent: number;
}

export interface WPTag {
  id: number;
  count: number;
  description: string;
  link: string;
  name: string;
  slug: string;
  taxonomy: string;
}

export interface WPUser {
  id: number;
  name: string;
  url: string;
  description: string;
  link: string;
  slug: string;
  avatar_urls: Record<string, string>;
}

// ============================================================================
// Fetch Helper
// ============================================================================

async function wpFetch<T>(endpoint: string, params: Record<string, any> = {}, defaultValue?: T): Promise<T> {
  const url = new URL(`${WP_REST_BASE}/${endpoint}`);
  
  Object.entries(params).forEach(([key, value]) => {
    if (value !== undefined && value !== null) {
      if (Array.isArray(value)) {
        url.searchParams.set(key, value.join(','));
      } else {
        url.searchParams.set(key, String(value));
      }
    }
  });
  
  try {
    const headers: Record<string, string> = { 'Accept': 'application/json' };
    if (WP_ACCESS_SECRET) {
      headers['X-PhantomWP-Secret'] = WP_ACCESS_SECRET;
    }
    
    const response = await fetch(url.toString(), { headers });
    
    if (!response.ok) {
      console.error(`WordPress API error: ${response.status} ${response.statusText}`);
      return defaultValue as T;
    }
    
    return response.json();
  } catch (error) {
    // Handle connection errors (ECONNREFUSED, network issues, etc.)
    console.error(`WordPress API connection failed for ${endpoint}:`, error instanceof Error ? error.message : error);
    return defaultValue as T;
  }
}

// ============================================================================
// Posts
// ============================================================================

export interface GetPostsOptions {
  page?: number;
  perPage?: number;
  search?: string;
  categories?: number[];
  tags?: number[];
  author?: number;
  orderBy?: 'date' | 'id' | 'title' | 'slug' | 'modified';
  order?: 'asc' | 'desc';
}

export async function getPosts(options: GetPostsOptions = {}): Promise<WPPost[]> {
  const posts = await wpFetch<WPPost[]>('posts', {
    page: options.page,
    per_page: options.perPage || 10,
    search: options.search,
    categories: options.categories,
    tags: options.tags,
    author: options.author,
    orderby: options.orderBy || 'date',
    order: options.order || 'desc',
    _embed: true,
  }, []);
  return processItems(posts);
}

export async function getAllPosts(): Promise<WPPost[]> {
  const allPosts: WPPost[] = [];
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const posts = await getPosts({ page, perPage: 100 });
    allPosts.push(...posts);
    hasMore = posts.length === 100;
    page++;
  }
  
  return allPosts;
}

export async function getPost(slug: string): Promise<WPPost | null> {
  const posts = await wpFetch<WPPost[]>('posts', { slug, _embed: true }, []);
  const post = posts && posts.length > 0 ? posts[0] : null;
  return post ? processItem(post) : null;
}

export async function getPostById(id: number): Promise<WPPost | null> {
  const post = await wpFetch<WPPost | null>(`posts/${id}`, { _embed: true }, null);
  return post ? processItem(post) : null;
}

export async function getPostsByCategory(categorySlug: string): Promise<WPPost[]> {
  const category = await getCategoryBySlug(categorySlug);
  if (!category) return [];
  return getPosts({ categories: [category.id], perPage: 100 });
}

export async function getPostsByTag(tagSlug: string): Promise<WPPost[]> {
  const tag = await getTagBySlug(tagSlug);
  if (!tag) return [];
  return getPosts({ tags: [tag.id], perPage: 100 });
}

// ============================================================================
// Pages
// ============================================================================

export interface GetPagesOptions {
  page?: number;
  perPage?: number;
  search?: string;
  parent?: number;
  orderBy?: 'date' | 'id' | 'title' | 'slug' | 'menu_order';
  order?: 'asc' | 'desc';
}

export async function getPages(options: GetPagesOptions = {}): Promise<WPPage[]> {
  const pages = await wpFetch<WPPage[]>('pages', {
    page: options.page,
    per_page: options.perPage || 10,
    search: options.search,
    parent: options.parent,
    orderby: options.orderBy || 'menu_order',
    order: options.order || 'asc',
    _embed: true,
  }, []);
  return processItems(pages);
}

export async function getAllPages(): Promise<WPPage[]> {
  const allPages: WPPage[] = [];
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const pages = await getPages({ page, perPage: 100 });
    allPages.push(...pages);
    hasMore = pages.length === 100;
    page++;
  }
  
  return allPages;
}

export async function getPage(slug: string): Promise<WPPage | null> {
  const pages = await wpFetch<WPPage[]>('pages', { slug, _embed: true }, []);
  const page = pages && pages.length > 0 ? pages[0] : null;
  return page ? processItem(page) : null;
}

export async function getPageById(id: number): Promise<WPPage | null> {
  const page = await wpFetch<WPPage | null>(`pages/${id}`, { _embed: true }, null);
  return page ? processItem(page) : null;
}

// ============================================================================
// Media
// ============================================================================

export async function getMedia(options: { page?: number; perPage?: number } = {}): Promise<WPMedia[]> {
  return wpFetch<WPMedia[]>('media', {
    page: options.page,
    per_page: options.perPage || 10,
  }, []);
}

export async function getMediaById(id: number): Promise<WPMedia | null> {
  return wpFetch<WPMedia | null>(`media/${id}`, {}, null);
}

// ============================================================================
// Categories
// ============================================================================

export async function getCategories(): Promise<WPCategory[]> {
  return wpFetch<WPCategory[]>('categories', { per_page: 100, hide_empty: false }, []);
}

export async function getCategoryBySlug(slug: string): Promise<WPCategory | null> {
  const categories = await wpFetch<WPCategory[]>('categories', { slug }, []);
  return categories && categories.length > 0 ? categories[0] : null;
}

export async function getCategoryById(id: number): Promise<WPCategory | null> {
  return wpFetch<WPCategory | null>(`categories/${id}`, {}, null);
}

// ============================================================================
// Tags
// ============================================================================

export async function getTags(): Promise<WPTag[]> {
  return wpFetch<WPTag[]>('tags', { per_page: 100, hide_empty: false }, []);
}

export async function getTagBySlug(slug: string): Promise<WPTag | null> {
  const tags = await wpFetch<WPTag[]>('tags', { slug }, []);
  return tags && tags.length > 0 ? tags[0] : null;
}

export async function getTagById(id: number): Promise<WPTag | null> {
  return wpFetch<WPTag | null>(`tags/${id}`, {}, null);
}

// ============================================================================
// Users/Authors
// ============================================================================

export async function getUsers(): Promise<WPUser[]> {
  return wpFetch<WPUser[]>('users', { per_page: 100 }, []);
}

export async function getUserById(id: number): Promise<WPUser | null> {
  return wpFetch<WPUser | null>(`users/${id}`, {}, null);
}

export async function getUserBySlug(slug: string): Promise<WPUser | null> {
  const users = await wpFetch<WPUser[]>('users', { slug }, []);
  return users && users.length > 0 ? users[0] : null;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Get the featured image URL from embedded data
 * @param post - The post or page with embedded data
 * @param size - The image size ('thumbnail', 'medium', 'large', 'full')
 * @returns The image URL or null if not found
 */
export function getFeaturedImageUrl(
  post: WPPost | WPPage,
  size: 'thumbnail' | 'medium' | 'large' | 'full' = 'full'
): string | null {
  const media = post._embedded?.['wp:featuredmedia']?.[0];
  if (!media) return null;
  
  if (size === 'full') {
    return media.source_url;
  }
  
  return media.media_details?.sizes?.[size]?.source_url || media.source_url;
}

/**
 * Get the author from embedded data
 * @param post - The post or page with embedded data
 * @returns The author or null if not found
 */
export function getAuthor(post: WPPost | WPPage): WPUser | null {
  return post._embedded?.author?.[0] || null;
}

/**
 * Get categories from embedded data (posts only)
 * @param post - The post with embedded data
 * @returns Array of categories
 */
export function getPostCategories(post: WPPost): WPCategory[] {
  const terms = post._embedded?.['wp:term'];
  if (!terms) return [];
  return (terms[0] as WPCategory[]) || [];
}

/**
 * Get tags from embedded data (posts only)
 * @param post - The post with embedded data
 * @returns Array of tags
 */
export function getPostTags(post: WPPost): WPTag[] {
  const terms = post._embedded?.['wp:term'];
  if (!terms) return [];
  return (terms[1] as WPTag[]) || [];
}

/**
 * Strip HTML tags from content
 * @param html - HTML content string
 * @returns Plain text string
 */
export function stripHtml(html: string): string {
  return html.replace(/<[^>]+>/g, '');
}

/**
 * Truncate text to a maximum length
 * @param text - Text to truncate
 * @param maxLength - Maximum length
 * @returns Truncated text with ellipsis if needed
 */
export function truncate(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength).trim() + '...';
}

/**
 * Format a WordPress date string
 * @param dateString - ISO date string from WordPress
 * @param options - Intl.DateTimeFormat options
 * @returns Formatted date string
 */
export function formatDate(
  dateString: string,
  options: Intl.DateTimeFormatOptions = { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  }
): string {
  return new Date(dateString).toLocaleDateString('en-US', options);
}

// ============================================================================
// Media URL Rewriting (for local images)
// ============================================================================

// Import media map - this file should exist (even if empty: {})
// If you've downloaded media, this maps WordPress URLs to local paths
import mediaUrlMap from './media-map.json';

// Responsive image variants and LQIP placeholders (generated by sync-media script)
// These are loaded via dynamic import so the site still works if the files don't exist yet
let responsiveImageMap: Record<string, any> = {};
let imagePlaceholders: Record<string, any> = {};

async function loadOptionalJson(path: string) {
  try { return (await import(/* @vite-ignore */ path)).default; } catch { return {}; }
}

responsiveImageMap = await loadOptionalJson('./responsive-map.json');
imagePlaceholders = await loadOptionalJson('./image-placeholders.json');

/**
 * Load the media URL map - for backwards compatibility
 * No longer needs to be called, map is loaded via import
 */
export function loadMediaMap(): void {
  // No-op - map is loaded via import
}

/**
 * Normalize a filename for matching - removes size suffix, extension, and special chars
 * e.g., "image-1024x890.jpg" â†’ "image"
 */
function normalizeFilename(filename: string): string {
  return filename
    .split('?')[0] // Remove query string
    .replace(/-\d+x\d+(?=\.[^.]+$)/, '') // Remove WordPress size suffix (-1024x890)
    .replace(/\.[^.]+$/, '') // Remove extension
    .replace(/[^a-z0-9_-]/gi, '_') // Normalize special chars to underscore
    .toLowerCase();
}

/**
 * Get local image URL if available, otherwise return original
 * @param originalUrl - The original WordPress image URL
 * @returns Local path if downloaded, original URL otherwise
 */
export function getLocalImageUrl(originalUrl: string | null): string | null {
  if (!originalUrl) return null;
  const map = mediaUrlMap as Record<string, string>;
  
  // Direct match
  if (map[originalUrl]) return map[originalUrl];
  
  // Try to match by normalized filename (handles size variants like -1024x585.png)
  const urlFilename = originalUrl.split('/').pop() || '';
  const normalizedUrl = normalizeFilename(urlFilename);
  
  for (const [, localPath] of Object.entries(map)) {
    const localFilename = localPath.split('/').pop() || '';
    const normalizedLocal = normalizeFilename(localFilename);
    if (normalizedLocal === normalizedUrl) {
      return localPath;
    }
  }
  
  return originalUrl;
}

/**
 * Rewrite image URLs in HTML content to use local paths.
 * Generates responsive srcset attributes for content images.
 * Directly constructs local path from filename - no media map needed for matching.
 */
export function rewriteContentUrls(content: string): string {
  let result = content;
  let replacements = 0;
  const responsiveMap = responsiveImageMap;
  const placeholders = imagePlaceholders;
  
  // First, remove existing srcset and sizes attributes (WordPress generates its own)
  result = result.replace(/ srcset="[^"]*"/gi, '');
  result = result.replace(/ sizes="[^"]*"/gi, '');
  
  // Find all <img> tags with wp-content/uploads URLs and rewrite them
  result = result.replace(/<img([^>]*?)src="([^"]*wp-content\/uploads\/[^"]*)"([^>]*?)>/gi, (fullMatch, before, url, after) => {
    // Extract filename from URL
    const parts = url.split('/');
    const filename = parts[parts.length - 1] || '';
    if (!filename) return fullMatch;
    
    // Remove query string
    const cleanFilename = filename.split('?')[0];
    
    // Get the extension
    const extMatch = cleanFilename.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i);
    const ext = extMatch ? extMatch[1].toLowerCase() : '';
    if (!ext) return fullMatch;
    
    // Remove size suffix (-1024x890, -300x200, etc.)
    const sizePattern = /-[0-9]+x[0-9]+(?=\.[a-z]+$)/i;
    const withoutSize = cleanFilename.replace(sizePattern, '');
    
    // Clean the filename (same as download process)
    const baseFilename = withoutSize
      .replace(/[^a-zA-Z0-9._-]/g, '_')
      .toLowerCase();
    
    // Change extension to .webp (unless it's svg)
    const isSvg = ext === 'svg';
    const localFilename = isSvg 
      ? baseFilename 
      : baseFilename.replace(/\.(jpg|jpeg|png|gif)$/i, '.webp');
    
    // Construct the local path
    const localPath = '/media/cms/' + localFilename;
    
    replacements++;
    
    // Build responsive srcset if variants exist
    const variants = responsiveMap[localFilename];
    let srcsetAttr = '';
    let sizesAttr = '';
    
    if (variants && variants.length > 0) {
      // Build srcset with the responsive variants + the full-size original
      const srcsetParts = variants.map(v => `/media/cms/${v.file} ${v.width}w`);
      // Add full-size image to srcset (get its width from placeholders or use default)
      const placeholderData = placeholders[localFilename];
      const fullWidth = placeholderData?.width || 1200;
      srcsetParts.push(`${localPath} ${fullWidth}w`);
      srcsetAttr = ` srcset="${srcsetParts.join(', ')}"`;
      sizesAttr = ' sizes="(max-width: 640px) 100vw, (max-width: 1024px) 80vw, 100vw"';
    }
    
    // Add width/height from placeholders to prevent CLS
    let dimensionAttrs = '';
    const placeholderData = placeholders[localFilename];
    if (placeholderData) {
      // Only add if not already present in the tag
      if (!before.includes('width=') && !after.includes('width=')) {
        dimensionAttrs += ` width="${placeholderData.width}"`;
      }
      if (!before.includes('height=') && !after.includes('height=')) {
        dimensionAttrs += ` height="${placeholderData.height}"`;
      }
    }
    
    // Add loading="lazy" and decoding="async" if not already present
    let loadingAttr = '';
    if (!before.includes('loading=') && !after.includes('loading=')) {
      loadingAttr = ' loading="lazy"';
    }
    let decodingAttr = '';
    if (!before.includes('decoding=') && !after.includes('decoding=')) {
      decodingAttr = ' decoding="async"';
    }
    
    return `<img${before}src="${localPath}"${after}${srcsetAttr}${sizesAttr}${dimensionAttrs}${loadingAttr}${decodingAttr}>`;
  });
  
  if (replacements > 0) {
    console.log('[rewriteContentUrls] Rewrote', replacements, 'images with local paths + responsive srcset');
  }
  
  return result;
}

/**
 * Get featured image URL, preferring local path if available
 * @param post - The post or page with embedded data
 * @param size - The image size
 * @returns Local path if downloaded, remote URL otherwise
 */
export function getLocalFeaturedImageUrl(
  post: WPPost | WPPage,
  size: 'thumbnail' | 'medium' | 'large' | 'full' = 'full'
): string | null {
  const remoteUrl = getFeaturedImageUrl(post, size);
  return getLocalImageUrl(remoteUrl);
}

// ============================================================================
// Auto-rewrite WordPress URLs in fetched data
// ============================================================================

/**
 * Process post/page data to rewrite all WordPress image URLs to local paths.
 * This runs automatically on all fetched data so templates never see remote URLs.
 * - Rewrites content HTML images (wp-content/uploads -> /media/cms/)
 * - Rewrites excerpt HTML images
 * - Rewrites featured image source_url in embedded data
 * - Rewrites all size variants in media_details
 */
function processItem<T extends WPPost | WPPage>(item: T): T {
  if (!item) return item;
  
  // Rewrite content HTML
  if (item.content?.rendered) {
    item.content.rendered = rewriteContentUrls(item.content.rendered);
  }
  
  // Rewrite excerpt HTML (can contain images)
  if (item.excerpt?.rendered) {
    item.excerpt.rendered = rewriteContentUrls(item.excerpt.rendered);
  }
  
  // Rewrite featured image URLs in embedded data
  const media = item._embedded?.['wp:featuredmedia']?.[0];
  if (media?.source_url) {
    const localUrl = getLocalImageUrl(media.source_url);
    if (localUrl) media.source_url = localUrl;
    
    // Also rewrite size variants
    if (media.media_details?.sizes) {
      for (const size of Object.values(media.media_details.sizes)) {
        if (size.source_url) {
          const localSizeUrl = getLocalImageUrl(size.source_url);
          if (localSizeUrl) size.source_url = localSizeUrl;
        }
      }
    }
  }
  
  return item;
}

function processItems<T extends WPPost | WPPage>(items: T[]): T[] {
  return items.map(processItem);
}

// ============================================================================
// CMS Request Functions (Server-side & Client-side via Proxy)
// ============================================================================

/**
 * WordPress Access Token
 * 
 * Sent as X-PhantomWP-Secret header to authenticate requests.
 * Prefers the environment variable (set by Vercel/hosting) at build time,
 * falls back to the baked-in value (for local dev / codespace).
 */
const WP_ACCESS_SECRET = import.meta.env.WP_ACCESS_SECRET || 'pwp_GyDrZdkDmm9eBp2XcpN4tJI1RzFh4Dos';

/**
 * Response type for CMS requests
 */
export interface CMSResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  status?: number;
  code?: string;
}

/**
 * Options for makeCMSRequest
 */
export interface CMSRequestOptions {
  /** HTTP method (default: 'GET' for no body, 'POST' for body) */
  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  /** Additional headers to include */
  headers?: Record<string, string>;
  /** Override the access token (useful for client-side requests) */
  token?: string;
  /** Query parameters for GET requests */
  params?: Record<string, string | number | boolean | undefined>;
}

/**
 * Make an authenticated request to the WordPress REST API (SERVER-SIDE)
 * 
 * Use this for build-time data fetching in Astro pages.
 * For client-side requests (forms, comments), use makeCMSProxyRequest instead.
 * 
 * This function handles authentication and can be used to:
 * - Fetch protected content during build
 * - Call custom REST API endpoints at build time
 * - Interact with WordPress plugins that expose REST endpoints
 * 
 * @param route - The API route (e.g., 'wp/v2/posts')
 * @param body - Optional request body (object will be JSON stringified, FormData sent as-is)
 * @param options - Optional request configuration
 * @returns Promise with success status, data, and error info
 */
export async function makeCMSRequest<T = unknown>(
  route: string,
  body?: Record<string, unknown> | FormData | null,
  options: CMSRequestOptions = {}
): Promise<CMSResponse<T>> {
  const {
    method = body ? 'POST' : 'GET',
    headers = {},
    token = WP_ACCESS_SECRET,
    params = {},
  } = options;

  try {
    // Build URL with query params
    const cleanRoute = route.replace(/^\//, '');
    const url = new URL(`${WP_API_URL}/${cleanRoute}`);
    
    // Add query parameters for GET requests
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        url.searchParams.set(key, String(value));
      }
    });

    // Build headers
    const requestHeaders: Record<string, string> = {
      ...headers,
    };
    
    // Add auth header if token is available
    if (token) {
      requestHeaders['X-PhantomWP-Secret'] = token;
    }
    
    // Set content type for JSON body (FormData sets its own)
    if (body && !(body instanceof FormData)) {
      requestHeaders['Content-Type'] = 'application/json';
    }

    const response = await fetch(url.toString(), {
      method,
      headers: requestHeaders,
      body: body 
        ? (body instanceof FormData ? body : JSON.stringify(body))
        : undefined,
    });

    // Parse response
    let data: T | undefined;
    const contentType = response.headers.get('content-type');
    
    if (contentType?.includes('application/json')) {
      data = await response.json();
    } else {
      // For non-JSON responses, return the text as data
      const text = await response.text();
      data = text as unknown as T;
    }

    if (!response.ok) {
      // Try to extract error message from WordPress error response
      const errorMessage = typeof data === 'object' && data !== null && 'message' in data
        ? String((data as { message: string }).message)
        : `Request failed with status ${response.status}`;
      
      return {
        success: false,
        data,
        error: errorMessage,
        status: response.status,
      };
    }

    return {
      success: true,
      data,
      status: response.status,
    };
  } catch (error) {
    console.error('[makeCMSRequest] Error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Network error',
    };
  }
}

// ============================================================================
// SEO Helpers - Extract SEO data from WordPress SEO plugins
// Supports: Yoast SEO, Rank Math, All in One SEO
// Falls back gracefully when no SEO plugin is installed
// ============================================================================

export interface WPSEOData {
  title?: string;
  description?: string;
  canonicalUrl?: string;
  ogTitle?: string;
  ogDescription?: string;
  ogImage?: string;
  ogType?: string;
  twitterTitle?: string;
  twitterDescription?: string;
  twitterImage?: string;
  twitterCard?: string;
  robots?: {
    index: boolean;
    follow: boolean;
  };
}

/**
 * Extract unified SEO data from any supported plugin.
 * Returns an empty object if no SEO plugin data is found (safe to use).
 */
export function extractSEOData(post: any): WPSEOData {
  if (!post) return {};
  const seo: WPSEOData = {};

  try {
    // Try Yoast SEO first (most common)
    if (post.yoast_head_json) {
      const yoast = post.yoast_head_json;
      seo.title = yoast.title;
      seo.description = yoast.description;
      seo.canonicalUrl = yoast.canonical;
      seo.ogTitle = yoast.og_title;
      seo.ogDescription = yoast.og_description;
      seo.ogImage = yoast.og_image?.[0]?.url;
      seo.ogType = yoast.og_type;
      seo.twitterTitle = yoast.twitter_title;
      seo.twitterDescription = yoast.twitter_description;
      seo.twitterImage = yoast.twitter_image;
      seo.twitterCard = yoast.twitter_card;
      if (yoast.robots) {
        seo.robots = {
          index: yoast.robots.index !== 'noindex',
          follow: yoast.robots.follow !== 'nofollow',
        };
      }
      return seo;
    }

    // Try Rank Math
    if (post.rank_math) {
      const rm = post.rank_math;
      seo.title = rm.title;
      seo.description = rm.description;
      seo.canonicalUrl = rm.canonical_url;
      seo.ogTitle = rm.og_title;
      seo.ogDescription = rm.og_description;
      seo.ogImage = rm.og_image;
      seo.twitterTitle = rm.twitter_title;
      seo.twitterDescription = rm.twitter_description;
      seo.twitterImage = rm.twitter_image;
      if (rm.robots) {
        seo.robots = {
          index: !rm.robots.includes('noindex'),
          follow: !rm.robots.includes('nofollow'),
        };
      }
      return seo;
    }

    // Try All in One SEO
    if (post.aioseo) {
      const aio = post.aioseo;
      seo.title = aio.title;
      seo.description = aio.description;
      seo.canonicalUrl = aio.canonical;
      seo.ogTitle = aio.og_title;
      seo.ogDescription = aio.og_description;
      seo.ogImage = aio.og_image;
      seo.twitterTitle = aio.twitter_title;
      seo.twitterDescription = aio.twitter_description;
      seo.twitterImage = aio.twitter_image;
      seo.twitterCard = aio.twitter_card;
      seo.robots = {
        index: !aio.robots_noindex,
        follow: !aio.robots_nofollow,
      };
      return seo;
    }
  } catch (e) {
    // If anything goes wrong parsing SEO data, return empty safely
    console.warn('[extractSEOData] Failed to parse SEO data:', e);
  }

  return seo;
}

/**
 * Get the best available title for a post/page.
 * Priority: SEO plugin title > post title > fallback
 */
export function getSEOTitle(post: any, fallback: string = ''): string {
  if (!post) return fallback;
  try {
    const seo = extractSEOData(post);
    return seo.title || post.title?.rendered || fallback;
  } catch {
    return post?.title?.rendered || fallback;
  }
}

/**
 * Get the best available description for a post/page.
 * Priority: SEO plugin description > excerpt (stripped of HTML) > fallback
 */
export function getSEODescription(post: any, fallback: string = ''): string {
  if (!post) return fallback;
  try {
    const seo = extractSEOData(post);
    if (seo.description) return seo.description;
    const excerpt = post.excerpt?.rendered || '';
    return stripHtml(excerpt).trim() || fallback;
  } catch {
    return fallback;
  }
}

/**
 * Get the best available OG/social image for a post/page.
 * Priority: SEO plugin OG image > featured image > null
 */
export function getSEOImage(post: any): string | null {
  if (!post) return null;
  try {
    const seo = extractSEOData(post);
    if (seo.ogImage) return getLocalImageUrl(seo.ogImage);
    return getLocalFeaturedImageUrl(post);
  } catch {
    return getLocalFeaturedImageUrl(post);
  }
}

// ============================================================================
// Custom Post Types
// ============================================================================

/**
 * Fetch items from a custom post type by its REST base.
 * The rest_base is found via /wp/v2/types (e.g., 'team-members', 'products').
 *
 * @param restBase - The REST base slug of the custom post type
 * @param options - Pagination and search options
 * @returns Array of items
 */
export async function getCustomPostType(restBase: string, options: {
  page?: number;
  perPage?: number;
  search?: string;
} = {}): Promise<any[]> {
  // Strip wp/v2/ prefix if accidentally included to prevent URL doubling
  const cleanBase = restBase.replace(/^\/?wp\/v2\//, '');
  return wpFetch<any[]>(cleanBase, {
    page: options.page,
    per_page: options.perPage || 100,
    search: options.search,
    _embed: true,
  }, []);
}

/**
 * Fetch a single item from a custom post type by slug.
 *
 * @param restBase - The REST base slug of the custom post type
 * @param slug - The item slug
 * @returns The item or null if not found
 */
export async function getCustomPostTypeItem(restBase: string, slug: string): Promise<any | null> {
  const cleanBase = restBase.replace(/^\/?wp\/v2\//, '');
  const items = await wpFetch<any[]>(cleanBase, { slug, _embed: true }, []);
  return items && items.length > 0 ? items[0] : null;
}

/**
 * Fetch a single item from a custom post type by ID.
 *
 * @param restBase - The REST base slug of the custom post type
 * @param id - The item ID
 * @returns The item or null if not found
 */
export async function getCustomPostTypeById(restBase: string, id: number): Promise<any | null> {
  const cleanBase = restBase.replace(/^\/?wp\/v2\//, '');
  return wpFetch<any | null>(`${cleanBase}/${id}`, { _embed: true }, null);
}
